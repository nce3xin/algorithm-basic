# 全排列

如何用 dfs 解决全排列问题？

dfs 最重要的是搜索顺序。用什么顺序遍历所有方案。

对于全排列问题，以 n = 3 为例，可以这样进行搜索：

![](imgs/1.png)

假设有 3 个空位，从前往后填数字，每次填一个位置，填的数字不能和前面一样。

最开始的时候，三个空位都是空的：__ __ __

首先填写第一个空位，第一个空位可以填 1，填写后为：1 __ __

填好第一个空位，填第二个空位，第二个空位可以填 2，填写后为：1 2 __

填好第二个空位，填第三个空位，第三个空位可以填 3，填写后为： 1 2 3

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

然后往后退一步，退到了状态：1 2 __ 。剩余第三个空位没有填数。第三个空位上除了填过的 3 ，没有其他数字可以填。

因此再往后退一步，退到了状态：1 __ __。第二个空位上除了填过的 2，还可以填 3。第二个空位上填写 3，填写后为：1 3 __

填好第二个空位，填第三个空位，第三个空位可以填 2，填写后为： 1 3 2

**这时候，空位填完，无法继续填数，所以这是一种方案，输出。**

以此类推，输出所有方案。

## 算法

- 用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。
- 用 vis 数组表示数字是否用过。当 vis[i] 为 true 时：i 已经被用过，vis[i] 为 false 时，i 没有被用过。
- dfs(i) 表示的含义是：在 path[i] 处填写数字，然后递归的在下一个位置填写数字。
- 回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。
